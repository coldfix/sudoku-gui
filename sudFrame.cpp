/////////////////////////////////////////////////////////////////////////////
// Name:        sudFrame.cpp
// Purpose:     
// Author:      Thomas Gl‰ﬂle
// Modified by: 
// Created:     16/07/2007 18:43:18
// RCS-ID:      
// Copyright:   Thomas Gl‰ﬂle (C) 2007
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (Personal Edition), 16/07/2007 18:43:18

#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
#pragma implementation "sudFrame.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
#include "sudGrid.h"
////@end includes

#include "sudFrame.h"
#include "sudEditor.h"

#include <gwx/AboutBox.h>
#include "sudokucreationdialog.h"
#include "sudGen.h"

#include <wx/wfstream.h>
#include <wx/txtstrm.h>
#include <wx/filename.h>
#include <wx/filedlg.h>

#include <wx/dnd.h>		/*drop target*/

#include "waitdialog.h"

#include "debug.h"


////@begin XPM images
#include "icon1.xpm"
////@end XPM images
#include "symbol.xpm"

#include "about.h"



/*!
 * sudFrame type definition
 */

IMPLEMENT_CLASS( sudFrame, wxFrame )


/*!
 * sudFrame event table definition
 */

BEGIN_EVENT_TABLE( sudFrame, wxFrame )

    EVT_MENU_RANGE( ID_MENUITEM_VIEW_SMALL, ID_MENUITEM_VIEW_BIG, sudFrame::OnMenuitemViewSizeClick )

////@begin sudFrame event table entries
    EVT_MENU( wxID_NEW, sudFrame::OnNewClick )

    EVT_MENU( wxID_OPEN, sudFrame::OnOpenClick )

    EVT_MENU( wxID_SAVE, sudFrame::OnSaveClick )

    EVT_MENU( wxID_EXIT, sudFrame::OnExitClick )

    EVT_UPDATE_UI( ID_MENUITEM_VIEW_SMALL, sudFrame::OnMenuitemViewSmallUpdate )

    EVT_UPDATE_UI( ID_MENUITEM_VIEW_NORMAL, sudFrame::OnMenuitemViewNormalUpdate )

    EVT_UPDATE_UI( ID_MENUITEM_VIEW_BIG, sudFrame::OnMenuitemViewBigUpdate )

    EVT_MENU( wxID_ABOUT, sudFrame::OnAboutClick )

    EVT_TOGGLEBUTTON( ID_SOLVER_SHOW_SOLUTION, sudFrame::OnSolverShowSolutionClick )
    EVT_UPDATE_UI( ID_SOLVER_SHOW_SOLUTION, sudFrame::OnSolverShowSolutionUpdate )

    EVT_BUTTON( ID_SOLVER_GENERATE, sudFrame::OnSolverGenerateClick )

    EVT_TOGGLEBUTTON( ID_SOLVER_ENTER_SUDOKU, sudFrame::OnSolverEnterSudokuClick )
    EVT_UPDATE_UI( ID_SOLVER_ENTER_SUDOKU, sudFrame::OnSolverEnterSudokuUpdate )

    EVT_UPDATE_UI( ID_STATUSBAR1, sudFrame::OnStatusbar1Update )

////@end sudFrame event table entries

END_EVENT_TABLE()


/*!
 * sudFrame constructors
 */

sudFrame::sudFrame()
{
    Init();
}

sudFrame::sudFrame( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
    Init();
    Create( parent, id, caption, pos, size, style );
}


/*!
 * sudFrame creator
 */

bool sudFrame::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin sudFrame creation
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    SetIcon(GetIconResource(wxT("icon1.xpm")));
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end sudFrame creation
    return true;
}


/*!
 * sudFrame destructor
 */

sudFrame::~sudFrame()
{
	sudGen::UnInit();
	delete m_crtdlg;
////@begin sudFrame destruction
////@end sudFrame destruction
}


/*!
 * Member initialisation
 */

void sudFrame::Init()
{
////@begin sudFrame member initialisation
    m_difficulty = sudGen::difficulty_medium;
    m_button_showsolution = NULL;
    m_button_entersudoku = NULL;
////@end sudFrame member initialisation

	sudGen::Init();
	m_generated = false;
}


/*!
 * Control creation for sudFrame
 */

void sudFrame::CreateControls()
{

////@begin sudFrame content construction
    // Generated by DialogBlocks, 19/12/2007 21:20:34 (Personal Edition)

    sudFrame* itemFrame1 = this;

    wxMenuBar* menuBar = new wxMenuBar;
    wxMenu* itemMenu3 = new wxMenu;
    itemMenu3->Append(wxID_NEW, _("&New\tCtrl+N"), _("Create a new sudoku field with specified size"), wxITEM_NORMAL);
    itemMenu3->Append(wxID_OPEN, _("&Open\tCtrl+O"), _("Load a sudoku from a text file"), wxITEM_NORMAL);
    itemMenu3->Append(wxID_SAVE, _("&Save\tCtrl+S"), _("Save current sudoku to a text file"), wxITEM_NORMAL);
    itemMenu3->AppendSeparator();
    itemMenu3->Append(wxID_EXIT, _("&Exit\tEsc"), _("Exit the application"), wxITEM_NORMAL);
    menuBar->Append(itemMenu3, _("&Sudoku"));
    wxMenu* itemMenu9 = new wxMenu;
    itemMenu9->Append(ID_MENUITEM_VIEW_SMALL, _("&Small"), _T(""), wxITEM_CHECK);
    itemMenu9->Append(ID_MENUITEM_VIEW_NORMAL, _("&Medium"), _T(""), wxITEM_CHECK);
    itemMenu9->Check(ID_MENUITEM_VIEW_NORMAL, true);
    itemMenu9->Append(ID_MENUITEM_VIEW_BIG, _("&Large"), _T(""), wxITEM_CHECK);
    menuBar->Append(itemMenu9, _("&View"));
    wxMenu* itemMenu13 = new wxMenu;
    itemMenu13->Append(wxID_ABOUT, _("&About...\tF9"), _("About Sudoku-Solver"), wxITEM_NORMAL);
    menuBar->Append(itemMenu13, _("&?"));
    itemFrame1->SetMenuBar(menuBar);

    wxBoxSizer* itemBoxSizer15 = new wxBoxSizer(wxHORIZONTAL);
    itemFrame1->SetSizer(itemBoxSizer15);

    wxBoxSizer* itemBoxSizer16 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer15->Add(itemBoxSizer16, 1, wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT, 25);

    wxBoxSizer* itemBoxSizer17 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer16->Add(itemBoxSizer17, 0, wxALIGN_CENTER_HORIZONTAL|wxLEFT|wxRIGHT|wxTOP, 10);

    m_sudgrid = new sudGrid( itemFrame1, sudGrid::ID_GRID, wxDefaultPosition, wxDefaultSize, 0 );
    m_sudgrid->SetDefaultColSize(0);
    m_sudgrid->SetDefaultRowSize(0);
    m_sudgrid->SetColLabelSize(0);
    m_sudgrid->SetRowLabelSize(0);
    m_sudgrid->CreateGrid(3, 3, wxGrid::wxGridSelectCells);
    itemBoxSizer17->Add(m_sudgrid, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer19 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer17->Add(itemBoxSizer19, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_button_showsolution = new wxToggleButton( itemFrame1, ID_SOLVER_SHOW_SOLUTION, _("&Show Solution"), wxDefaultPosition, wxDefaultSize, 0 );
    m_button_showsolution->SetValue(false);
    m_button_showsolution->SetHelpText(_("Blends in the solution of the sudoku"));
    if (sudFrame::ShowToolTips())
        m_button_showsolution->SetToolTip(_("Blends in the solution of the sudoku"));
    itemBoxSizer19->Add(m_button_showsolution, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton21 = new wxButton( itemFrame1, ID_SOLVER_GENERATE, _("&Generate"), wxDefaultPosition, wxDefaultSize, 0 );
    itemButton21->SetHelpText(_("Generate a new sudoku"));
    if (sudFrame::ShowToolTips())
        itemButton21->SetToolTip(_("Generate a new sudoku"));
    itemBoxSizer19->Add(itemButton21, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_button_entersudoku = new wxToggleButton( itemFrame1, ID_SOLVER_ENTER_SUDOKU, _("&Edit Sudoku"), wxDefaultPosition, wxDefaultSize, 0 );
    m_button_entersudoku->SetValue(false);
    m_button_entersudoku->SetHelpText(_("Enter your own numbers to create a riddle"));
    if (sudFrame::ShowToolTips())
        m_button_entersudoku->SetToolTip(_("Enter your own numbers to create a riddle"));
    itemBoxSizer19->Add(m_button_entersudoku, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxStatusBar* itemStatusBar23 = new wxStatusBar( itemFrame1, ID_STATUSBAR1, wxST_SIZEGRIP|wxNO_BORDER );
    itemStatusBar23->SetFieldsCount(1);
    itemFrame1->SetStatusBar(itemStatusBar23);

////@end sudFrame content construction

	m_sudgrid->setdisplaysize(1);

	/* drop target */
	class sudDropTarget : public wxFileDropTarget{
	public:
		sudDropTarget(sudFrame* droptarget)	{ m_droptarget = droptarget; }
		bool OnDropFiles(wxCoord x, wxCoord y, const wxArrayString& filenames){
			size_t nFiles = filenames.GetCount();
			if(nFiles!=1)		// we're accepting the drop of only one file
				return false;
			m_droptarget->LoadFile( filenames[0] );
			return true; }
	private:
		sudFrame* m_droptarget;
	};
	SetDropTarget( new sudDropTarget(this) );

	m_crtdlg = new SudokuCreationDialog(this);
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_NEW
 */

void sudFrame::OnNewClick( wxCommandEvent& event )
{
	m_crtdlg->SetDifficulty( GetDifficulty() );
	if(m_crtdlg->ShowModal() == wxID_OK){
		wxSize dim = m_crtdlg->GetDimensions();
		m_sudgrid->NewGrid( dim.x,dim.y );
		SetDifficulty( m_crtdlg->GetDifficulty() );
		if( m_crtdlg->GetGenerateSudoku() )
			sudGenerate();
		else
			m_generated = false;
		SetCurrentFile(wxEmptyString);
	}
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_OPEN
 */

void sudFrame::OnOpenClick( wxCommandEvent& event )
{
	wxFileDialog fdlg(this,wxT("Load file"),
					GetCurrentDirectory(),GetCurrentFile(),
					wxT("Sudoku field|*.txt"),wxFD_OPEN|wxFD_FILE_MUST_EXIST);
	if(fdlg.ShowModal()==wxID_OK){
		LoadFile(fdlg.GetPath());
	}
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_SAVE
 */

void sudFrame::OnSaveClick( wxCommandEvent& event )
{
	wxFileDialog fdlg(this,wxT("Save to"),
					GetCurrentDirectory(),wxFileName(GetCurrentFile()).GetName(),
					wxT("Text file|*.txt|Html file|*.html"),wxFD_OVERWRITE_PROMPT|wxFD_SAVE);
	if(fdlg.ShowModal()==wxID_OK){
		wxFileName fname = fdlg.GetPath();
		SetCurrentDirectory(fname.GetPath());
		SetCurrentFile(fname.GetFullName());

		wxFileOutputStream fo(fdlg.GetPath());
		if(!fo.Ok()){
			wxMessageBox(wxT("Could not open file for writing!"),wxT("wxSudoku"),wxOK|wxCENTRE|wxICON_ERROR,this);
		}else{
			wxTextOutputStream text(fo);
			if(fdlg.GetFilterIndex()==0){
				GetEditor()->GetRiddle()->save(text);	// todo: save not only riddle but merged with user ipt?
			}else{
				text << sudSaveHtml();
			}
		}
	}
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_EXIT
 */

void sudFrame::OnExitClick( wxCommandEvent& event )
{
    Close(true);
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM3
 */

void sudFrame::OnAboutClick( wxCommandEvent& event )
{
	gwxAboutBox dlg(this,wxID_ANY,about_title );
	dlg.SetDescription(g_DescriptionTxt);
	dlg.SetAppname(about_appname);
	dlg.SetCopyright(about_copyright);
	dlg.SetBigIcon( about_icon );
	dlg.ShowModal();
}

/*!
 * Should we show tooltips?
 */

bool sudFrame::ShowToolTips()
{
    return true;
}


/*!
 * Get bitmap resources
 */

wxBitmap sudFrame::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
    if (name == _T("symbol.xpm"))
    {
        wxBitmap bitmap(symbol_xpm);
        return bitmap;
    }
////@begin sudFrame bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end sudFrame bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon sudFrame::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin sudFrame icon retrieval
    wxUnusedVar(name);
    if (name == _T("icon1.xpm"))
    {
        wxIcon icon(icon1_xpm);
        return icon;
    }
    return wxNullIcon;
////@end sudFrame icon retrieval
}





/*!
 * wxEVT_COMMAND_CHECKBOX_CLICKED event handler for ID_SOLVER_SHOW_SOLUTION
 */

void sudFrame::OnSolverShowSolutionClick( wxCommandEvent& event )
{
	GetEditor()->SetShowSolution( ! GetEditor()->GetShowSolution() );
	m_sudgrid->SetFocus();
}


/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_SOLVER_ENTER_SUDOKU
 */

void sudFrame::OnSolverEnterSudokuClick( wxCommandEvent& event )
{
	m_generated = false;

	bool ok = GetEditor()->EnterInitMode( ! GetEditor()->IsInitMode() );
	if(GetEditor()->IsInitMode() && !ok)
		wxMessageBox(wxT("Could not switch to User-Mode, since Sudoku is not uniquely solvable!"),
					wxT("wxSudoku"), wxOK|wxICON_ERROR|wxCENTRE, this );

	m_sudgrid->SetFocus();
	// todo: error output?
}


/*!
 * wxEVT_UPDATE_UI event handler for ID_SOLVER_ENTER_SUDOKU
 */

void sudFrame::OnSolverEnterSudokuUpdate( wxUpdateUIEvent& event )
{
	//event.Check( GetEditor()->IsInitMode() );		// ! ... ?

	((wxToggleButton*)FindWindow(ID_SOLVER_ENTER_SUDOKU))->SetValue( GetEditor()->IsInitMode() );
}

/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_SOLVER_GENERATE
 */

void sudFrame::OnSolverGenerateClick( wxCommandEvent& event )
{
	sudGenerate();
	m_sudgrid->SetFocus();
}


void sudFrame::sudGenerate(){

	bool success;
	sudSize size = * GetEditor()->GetSize();
	sudGen generator;

	if( size.high() >= 16 ){
		sudWaitDialog* waitdialog = new sudWaitDialog(&generator,this);
		waitdialog->Show(true);
		{
			wxWindowDisabler disabler(waitdialog);
			success = generator.generate( size.bx(), size.by(), GetDifficulty() );
		}
		waitdialog->Close();
	}else{
		success = generator.generate( size.bx(), size.by(), GetDifficulty() );
	}

	if(success){
		m_sudgrid->InitFromSudoku( generator.GetRiddle() );
		SetCurrentFile(wxEmptyString);
		m_generated = true;
		m_gentime = generator.gentime();
		m_reducetime = generator.reducetime();
	}
}


sudEditor* sudFrame::GetEditor() const{
	return m_sudgrid->GetEditor(); }


/*!
 * wxEVT_UPDATE_UI event handler for ID_SOLVER_SHOW_SOLUTION
 */

void sudFrame::OnSolverShowSolutionUpdate( wxUpdateUIEvent& event )
{
//	event.Check( GetEditor()->GetShowSolution() );		// ! ... ?
	
	((wxToggleButton*)FindWindow(ID_SOLVER_SHOW_SOLUTION))->SetValue( GetEditor()->GetShowSolution() );
}


/*!
 * wxEVT_UPDATE_UI event handler for ID_STATUSBAR1
 */

void sudFrame::OnStatusbar1Update( wxUpdateUIEvent& event )
{
	const sudSolve* solver = & GetEditor()->GetSolver();
	int difficulty;

	wxString text;

	if(!GetEditor()->GetRiddle()->getsolved() && GetEditor()->GetRiddle()->size()!=1)
		text = wxEmptyString; //wxT("Welcome to wxSudoku!");
	else if( solver->error() )
		text = wxT("The sudoku is not valid.");
	else if( solver->multiple() )
		text = wxT("The sudoku is ambiguous.");
	else if( solver->toohard() )
		text = wxEmptyString;
	else{
		int difficulty = solver->difficulty();
		if( difficulty==sudSolve::difficulty_hard )
			text = wxT("Hard");
		else if(difficulty==sudSolve::difficulty_medium)
			text = wxT("Medium difficulty");
		else
			text = wxT("Low difficulty");

	}

	if(m_generated)
		text += wxString::Format( wxT(" (%i ms / %i ms)"), m_gentime, m_reducetime );

	SetStatusText( text );

/*	text = m_generated
		? wxString::Format( wxT("%i ms / %i ms"), sudGen::gentime(), sudGen::reducetime() )
		: wxEmptyString;
	SetStatusText( text, 1 );*/
}


#include"html_templates.h"


bool hasborder(int num,int dim,int high){
	return !(num%dim) && num && num!=high; }


wxString sudFrame::sudSaveHtml(){
	const sudEditor* ed = GetEditor();
	int fx=ed->GetSize()->fx(),fy=ed->GetSize()->fy(),h=fx*fy;
	wxString file = g_TplFileTxt;
	wxString rows;

	for(int y=0;y<h;y++){
		wxString row = g_TplRowTxt;
		wxString cells;
		wxString tbclass = wxString::Format(wxT("%s %s"),hasborder(y,fy,h)?wxT("topborder"):wxEmptyString,
														 hasborder(y+1,fy,h)?wxT("bottomborder"):wxEmptyString);
		tbclass.Trim(0);
		tbclass.Trim(1);
		for(int x=0;x<h;x++){
			wxString cell = g_TplCellTxt;
			wxString number = ed->GetCell(x,y) ? wxString::Format(wxT("%ld"),ed->GetCell(x,y)) : wxEmptyString;
			cell.Replace(wxT("%NUMBER%"), number );

			wxString cellclass, mode;
			switch(ed->GetCellMode(x,y)){
				case sudEditor::cellmode_riddle:
					mode = wxT("riddle");
					break;
				case sudEditor::cellmode_user_correct:
					mode = wxT("user");
					break;
				case sudEditor::cellmode_user_incorrect:
					mode = wxT("incorrect");
					break;
				case sudEditor::cellmode_solution:
					mode = wxT("solution");
					break;
				case sudEditor::cellmode_invalid:
					mode = wxT("invalid");
					break;
			};

			wxString tbrlclass = wxString::Format(wxT("%s %s %s %s"),mode, tbclass,
														hasborder(x,fx,h)?wxT("leftborder"):wxEmptyString,
														hasborder(x+1,fx,h)?wxT("rightborder"):wxEmptyString);
			tbrlclass.Trim(0);
			tbrlclass.Trim(1);
			tbrlclass.Replace(wxT("   "),wxT(" "));
			tbrlclass.Replace(wxT("  "),wxT(" "));
			cell.Replace(wxT("%CLASS%"), tbrlclass );

			cells += cell;
		}

		row.Replace( wxT("%CELLS%"), cells );
		row.Replace( wxT("%CLASS%"), wxEmptyString );	/* we could also pass tbclass here */
		rows += row;
	}

	file.Replace( wxT("%ROWS%"), rows );
	return file; }


void sudFrame::LoadFile(wxString filename){
	wxFileName fname = filename;
	SetCurrentDirectory(fname.GetPath());
	SetCurrentFile(fname.GetFullName());

	Sudoku sud;
	wxFileInputStream fi( filename );
	wxTextInputStream text(fi);
	sud.load<wxTextInputStream>(text);
	m_sudgrid->InitFromSudoku(sud);

	m_generated = false;

	GetEditor()->EnterInitMode(0);
}









/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_VIEW_SMALL
 */

void sudFrame::OnMenuitemViewSizeClick( wxCommandEvent& event )
{
	m_sudgrid->setdisplaysize( event.GetId() - ID_MENUITEM_VIEW_SMALL );
	GetSizer()->SetSizeHints(this);
}


/*!
 * wxEVT_UPDATE_UI event handler for ID_MENUITEM_VIEW_SMALL
 */

void sudFrame::OnMenuitemViewSmallUpdate( wxUpdateUIEvent& event )
{
	event.Check( m_sudgrid->getdisplaysize()==0 );
}


/*!
 * wxEVT_UPDATE_UI event handler for ID_MENUITEM_VIEW_NORMAL
 */

void sudFrame::OnMenuitemViewNormalUpdate( wxUpdateUIEvent& event )
{
	event.Check( m_sudgrid->getdisplaysize()==1 );
}


/*!
 * wxEVT_UPDATE_UI event handler for ID_MENUITEM_VIEW_BIG
 */

void sudFrame::OnMenuitemViewBigUpdate( wxUpdateUIEvent& event )
{
	event.Check( m_sudgrid->getdisplaysize()==2 );
}

